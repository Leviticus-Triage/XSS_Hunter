#!/usr/bin/env python3
# -*- coding: utf-8 -*-

"""
XSS Hunter Pro Framework - Vulnerability Scanner Integration
===========================================================

Dieses Modul enthält Integrationen für verschiedene Vulnerability Scanner.

Autor: Anonymous
Lizenz: MIT
Version: 0.3.0
"""

import os
import sys
import json
import subprocess
import logging
import re
import time
from abc import ABC, abstractmethod

# Füge das Hauptverzeichnis zum Pfad hinzu, um Module zu importieren
sys.path.append(os.path.dirname(os.path.dirname(os.path.abspath(__file__))))

try:
    import utils
except ImportError:
    logger = logging.getLogger("XSSHunterPro.VulnerabilityScanner")
    logger.warning("Utils-Modul konnte nicht importiert werden. Verwende einfache Implementierungen.")
    
    class SimpleUtils:
        @staticmethod
        def create_directory(directory_path):
            if not directory_path:
                return False
            try:
                os.makedirs(directory_path, exist_ok=True)
                return True
            except Exception as e:
                print(f"Fehler beim Erstellen des Verzeichnisses {directory_path}: {e}")
                return False
                
        @staticmethod
        def load_json_file(file_path):
            try:
                if not os.path.exists(file_path):
                    print(f"Datei nicht gefunden: {file_path}")
                    return None
                
                with open(file_path, 'r', encoding='utf-8') as f:
                    return json.load(f)
            except Exception as e:
                print(f"Fehler beim Laden der JSON-Datei {file_path}: {e}")
                return None
                
        @staticmethod
        def save_json_file(file_path, data):
            try:
                directory = os.path.dirname(file_path)
                if directory and not os.path.exists(directory):
                    os.makedirs(directory, exist_ok=True)
                    
                with open(file_path, 'w', encoding='utf-8') as f:
                    json.dump(data, f, indent=4, ensure_ascii=False)
                return True
            except Exception as e:
                print(f"Fehler beim Speichern der JSON-Datei {file_path}: {e}")
                return False
    
    utils = SimpleUtils()

# Konfiguriere Logging
logger = logging.getLogger("XSSHunterPro.VulnerabilityScanner")

class VulnerabilityScanner(ABC):
    """
    Basisklasse für Vulnerability Scanner Integrationen.
    """
    
    def __init__(self, config=None):
        """
        Initialisiert den Vulnerability Scanner.
        
        Args:
            config: Die Konfiguration für den Scanner.
        """
        self.config = config or {}
        self.results = []
        
    @abstractmethod
    def scan(self, target, options=None):
        """
        Führt einen Scan durch.
        
        Args:
            target: Das Ziel des Scans.
            options: Optionen für den Scan.
            
        Returns:
            Die Ergebnisse des Scans.
        """
        pass
        
    @abstractmethod
    def parse_results(self, raw_results):
        """
        Parst die Ergebnisse des Scans.
        
        Args:
            raw_results: Die Rohergebnisse des Scans.
            
        Returns:
            Die geparsten Ergebnisse.
        """
        pass
        
    def save_results(self, output_file):
        """
        Speichert die Ergebnisse des Scans.
        
        Args:
            output_file: Die Ausgabedatei.
            
        Returns:
            True, wenn das Speichern erfolgreich war, sonst False.
        """
        return utils.save_json_file(output_file, self.results)
        
    def get_results(self):
        """
        Gibt die Ergebnisse des Scans zurück.
        
        Returns:
            Die Ergebnisse des Scans.
        """
        return self.results

class NucleiIntegration(VulnerabilityScanner):
    """
    Integration für Nuclei.
    """
    
    def __init__(self, config=None):
        """
        Initialisiert die Nuclei-Integration.
        
        Args:
            config: Die Konfiguration für Nuclei.
        """
        super().__init__(config)
        self.nuclei_path = self.config.get("nuclei_path", "nuclei")
        self.templates_path = self.config.get("templates_path", "")
        
    def scan(self, target, options=None):
        """
        Führt einen Nuclei-Scan durch.
        
        Args:
            target: Das Ziel des Scans.
            options: Optionen für den Scan.
            
        Returns:
            Die Ergebnisse des Scans.
        """
        options = options or {}
        
        # Erstelle temporäre Datei für die Ausgabe
        output_file = options.get("output_file", f"nuclei_results_{int(time.time())}.json")
        
        # Erstelle Kommandozeile
        cmd = [self.nuclei_path, "-target", target, "-json", "-o", output_file]
        
        # Füge Templates hinzu, wenn angegeben
        if self.templates_path:
            cmd.extend(["-t", self.templates_path])
        
        # Füge zusätzliche Optionen hinzu
        if options.get("severity"):
            cmd.extend(["-severity", options["severity"]])
        
        if options.get("tags"):
            cmd.extend(["-tags", options["tags"]])
            
        if options.get("rate_limit"):
            cmd.extend(["-rate-limit", str(options["rate_limit"])])
            
        if options.get("timeout"):
            cmd.extend(["-timeout", str(options["timeout"])])
            
        # Führe Nuclei aus
        try:
            logger.info(f"Führe Nuclei-Scan aus: {' '.join(cmd)}")
            process = subprocess.Popen(cmd, stdout=subprocess.PIPE, stderr=subprocess.PIPE)
            stdout, stderr = process.communicate()
            
            if process.returncode != 0:
                logger.error(f"Nuclei-Scan fehlgeschlagen: {stderr.decode('utf-8')}")
                return []
                
            # Lade Ergebnisse aus der Ausgabedatei
            if os.path.exists(output_file):
                raw_results = utils.load_json_file(output_file)
                self.results = self.parse_results(raw_results)
                return self.results
            else:
                logger.error(f"Nuclei-Ausgabedatei nicht gefunden: {output_file}")
                return []
                
        except Exception as e:
            logger.error(f"Fehler beim Ausführen des Nuclei-Scans: {e}")
            return []
            
    def parse_results(self, raw_results):
        """
        Parst die Ergebnisse des Nuclei-Scans.
        
        Args:
            raw_results: Die Rohergebnisse des Scans.
            
        Returns:
            Die geparsten Ergebnisse.
        """
        if not raw_results:
            return []
            
        parsed_results = []
        
        for result in raw_results:
            parsed_result = {
                "type": "nuclei",
                "name": result.get("info", {}).get("name", "Unknown"),
                "severity": result.get("info", {}).get("severity", "Unknown"),
                "url": result.get("matched-at", ""),
                "description": result.get("info", {}).get("description", ""),
                "tags": result.get("info", {}).get("tags", []),
                "raw": result
            }
            
            parsed_results.append(parsed_result)
            
        return parsed_results

class ZapIntegration(VulnerabilityScanner):
    """
    Integration für OWASP ZAP.
    """
    
    def __init__(self, config=None):
        """
        Initialisiert die ZAP-Integration.
        
        Args:
            config: Die Konfiguration für ZAP.
        """
        super().__init__(config)
        self.zap_path = self.config.get("zap_path", "zap-cli")
        self.api_key = self.config.get("api_key", "")
        
    def scan(self, target, options=None):
        """
        Führt einen ZAP-Scan durch.
        
        Args:
            target: Das Ziel des Scans.
            options: Optionen für den Scan.
            
        Returns:
            Die Ergebnisse des Scans.
        """
        options = options or {}
        
        # Erstelle temporäre Datei für die Ausgabe
        output_file = options.get("output_file", f"zap_results_{int(time.time())}.json")
        
        # Erstelle Kommandozeile
        cmd = [self.zap_path, "--api-key", self.api_key, "quick-scan", "-s", "xss", target, "--output-format", "json", "--output-file", output_file]
        
        # Führe ZAP aus
        try:
            logger.info(f"Führe ZAP-Scan aus: {' '.join(cmd)}")
            process = subprocess.Popen(cmd, stdout=subprocess.PIPE, stderr=subprocess.PIPE)
            stdout, stderr = process.communicate()
            
            if process.returncode != 0:
                logger.error(f"ZAP-Scan fehlgeschlagen: {stderr.decode('utf-8')}")
                return []
                
            # Lade Ergebnisse aus der Ausgabedatei
            if os.path.exists(output_file):
                raw_results = utils.load_json_file(output_file)
                self.results = self.parse_results(raw_results)
                return self.results
            else:
                logger.error(f"ZAP-Ausgabedatei nicht gefunden: {output_file}")
                return []
                
        except Exception as e:
            logger.error(f"Fehler beim Ausführen des ZAP-Scans: {e}")
            return []
            
    def parse_results(self, raw_results):
        """
        Parst die Ergebnisse des ZAP-Scans.
        
        Args:
            raw_results: Die Rohergebnisse des Scans.
            
        Returns:
            Die geparsten Ergebnisse.
        """
        if not raw_results:
            return []
            
        parsed_results = []
        
        # ZAP-Ergebnisse können unterschiedliche Formate haben
        # Hier wird ein allgemeines Format angenommen
        alerts = raw_results.get("alerts", [])
        
        for alert in alerts:
            if "Cross Site Scripting" in alert.get("name", ""):
                parsed_result = {
                    "type": "zap",
                    "name": alert.get("name", "Unknown"),
                    "severity": alert.get("risk", "Unknown"),
                    "url": alert.get("url", ""),
                    "parameter": alert.get("param", ""),
                    "description": alert.get("description", ""),
                    "solution": alert.get("solution", ""),
                    "raw": alert
                }
                
                parsed_results.append(parsed_result)
                
        return parsed_results

# Import XSStrikeIntegration
try:
    from integrations.xsstrike_integration import XSStrikeIntegration
except ImportError:
    logger.warning("XSStrikeIntegration konnte nicht importiert werden. XSStrike-Funktionalität wird nicht verfügbar sein.")
    
    # Dummy-Implementierung für XSStrikeIntegration
    class XSStrikeIntegration(VulnerabilityScanner):
        def __init__(self, config=None):
            super().__init__(config)
            logger.warning("XSStrikeIntegration ist nur als Dummy-Implementierung verfügbar.")
            
        def scan(self, target, options=None):
            logger.error("XSStrikeIntegration ist nicht verfügbar. Scan kann nicht durchgeführt werden.")
            return []
            
        def parse_results(self, raw_results):
            return []
