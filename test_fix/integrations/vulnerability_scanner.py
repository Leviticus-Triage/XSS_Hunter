#!/usr/bin/env python3
# -*- coding: utf-8 -*-

"""
XSS Hunter Pro Framework - Vulnerability Scanner Integration
===========================================================

Diese Datei implementiert die Integration für Vulnerability Scanner Tools (Nuclei, XSStrike, Dalfox).

Autor: Anonymous
Lizenz: MIT
Version: 0.2.0
"""

import json
import os
import re
import logging
import tempfile
import subprocess
from typing import Dict, List, Any, Optional, Union, Tuple

from .base import ToolIntegration

# Konfiguration für Logging
logger = logging.getLogger("XSSHunterPro.Integrations.VulnerabilityScanner")


class NucleiIntegration(ToolIntegration):
    """Integration für das Nuclei Tool."""

    def _get_tool_name(self) -> str:
        """
        Gibt den Namen des Tools zurück.
        
        Returns:
            Der Name des Tools.
        """
        return "nuclei"
    
    def _get_installation_command(self) -> List[str]:
        """
        Gibt den Befehl zur Installation des Tools zurück.
        
        Returns:
            Eine Liste mit dem Installationsbefehl und seinen Argumenten.
        """
        return ["go", "install", "github.com/projectdiscovery/nuclei/v2/cmd/nuclei@latest"]
    
    def run(self, target: str, options: Optional[Dict[str, Any]] = None) -> Dict[str, Any]:
        """
        Führt Nuclei mit den angegebenen Optionen aus.
        
        Args:
            target: Die Ziel-URL oder Domain.
            options: Zusätzliche Optionen für Nuclei.
            
        Returns:
            Ein Dictionary mit den Ergebnissen der Ausführung.
        """
        if not self.executable_path:
            return {"error": f"{self._get_tool_name()} nicht gefunden oder installiert"}
        
        if options is None:
            options = {}
        
        # Standardoptionen
        timeout = options.get("timeout", 60)
        output_file = options.get("output_file", "")
        templates = options.get("templates", ["xss", "cve"])
        
        # Kommando zusammenstellen
        command = [
            self.executable_path,
            "-target", target,
            "-json"
        ]
        
        # Templates hinzufügen
        for template in templates:
            command.extend(["-t", template])
        
        # Optionale Parameter
        if "severity" in options:
            command.extend(["-severity", options["severity"]])
        
        if "rate_limit" in options:
            command.extend(["-rate-limit", str(options["rate_limit"])])
        
        if "concurrency" in options:
            command.extend(["-c", str(options["concurrency"])])
        
        if "timeout" in options:
            command.extend(["-timeout", str(options["timeout"])])
        
        if "headers" in options:
            for header, value in options["headers"].items():
                command.extend(["-H", f"{header}: {value}"])
        
        if output_file:
            command.extend(["-o", output_file])
        
        # Ausführen
        returncode, stdout, stderr = self.execute_command(command, timeout=timeout+30)
        
        # Ergebnisse verarbeiten
        results = {
            "tool": self._get_tool_name(),
            "target": target,
            "command": " ".join(command),
            "returncode": returncode,
            "vulnerabilities": [],
            "error": stderr if returncode != 0 else ""
        }
        
        if returncode == 0:
            # Verarbeite die Ausgabe
            for line in stdout.splitlines():
                try:
                    if line.strip():
                        data = json.loads(line)
                        
                        vulnerability = {
                            "template": data.get("template", ""),
                            "template-id": data.get("template-id", ""),
                            "name": data.get("info", {}).get("name", ""),
                            "severity": data.get("info", {}).get("severity", ""),
                            "type": data.get("type", ""),
                            "host": data.get("host", ""),
                            "matched": data.get("matched", ""),
                            "description": data.get("info", {}).get("description", ""),
                            "tags": data.get("info", {}).get("tags", []),
                            "reference": data.get("info", {}).get("reference", []),
                            "extracted-results": data.get("extracted-results", []),
                            "curl-command": data.get("curl-command", "")
                        }
                        
                        results["vulnerabilities"].append(vulnerability)
                except json.JSONDecodeError:
                    logger.warning(f"Konnte JSON nicht parsen: {line}")
        
        return results


class XSStrikeIntegration(ToolIntegration):
    """Integration für das XSStrike Tool."""

    def _get_tool_name(self) -> str:
        """
        Gibt den Namen des Tools zurück.
        
        Returns:
            Der Name des Tools.
        """
        return "xsstrike"
    
    def _get_installation_command(self) -> List[str]:
        """
        Gibt den Befehl zur Installation des Tools zurück.
        
        Returns:
            Eine Liste mit dem Installationsbefehl und seinen Argumenten.
        """
        return [
            "bash", "-c", 
            "git clone https://github.com/s0md3v/XSStrike.git /tmp/XSStrike && " +
            "cd /tmp/XSStrike && pip install -r requirements.txt && " +
            "cp -r /tmp/XSStrike $HOME/.local/ && " +
            "ln -sf $HOME/.local/XSStrike/xsstrike.py $HOME/.local/bin/xsstrike && " +
            "chmod +x $HOME/.local/bin/xsstrike"
        ]
    
    def _find_executable(self) -> Optional[str]:
        """
        Sucht nach dem ausführbaren Programm des Tools im System.
        
        Returns:
            Der Pfad zum ausführbaren Programm oder None, wenn es nicht gefunden wurde.
        """
        # Prüfe zuerst den Standard-Pfad
        executable_path = super()._find_executable()
        if executable_path:
            return executable_path
        
        # Prüfe alternative Pfade für XSStrike
        alternative_paths = [
            os.path.expanduser("~/.local/bin/xsstrike"),
            os.path.expanduser("~/.local/XSStrike/xsstrike.py"),
            "/usr/local/bin/xsstrike",
            "/opt/XSStrike/xsstrike.py"
        ]
        
        for path in alternative_paths:
            if os.path.isfile(path) and os.access(path, os.X_OK):
                return path
        
        return None
    
    def run(self, target: str, options: Optional[Dict[str, Any]] = None) -> Dict[str, Any]:
        """
        Führt XSStrike mit den angegebenen Optionen aus.
        
        Args:
            target: Die Ziel-URL.
            options: Zusätzliche Optionen für XSStrike.
            
        Returns:
            Ein Dictionary mit den Ergebnissen der Ausführung.
        """
        if not self.executable_path:
            return {"error": f"{self._get_tool_name()} nicht gefunden oder installiert"}
        
        if options is None:
            options = {}
        
        # Standardoptionen
        timeout = options.get("timeout", 120)
        output_file = options.get("output_file", "")
        
        # Temporäre Datei für die Ausgabe erstellen
        temp_output = ""
        if not output_file:
            temp_fd, temp_output = tempfile.mkstemp(suffix=".txt", prefix="xsstrike_")
            os.close(temp_fd)
            output_file = temp_output
        
        # Kommando zusammenstellen
        command = [
            "python3", self.executable_path,
            "--url", target
        ]
        
        # Optionale Parameter
        if "data" in options:
            command.extend(["--data", options["data"]])
        
        if "headers" in options:
            headers_str = ""
            for header, value in options["headers"].items():
                headers_str += f"{header}: {value}\\n"
            command.extend(["--headers", headers_str])
        
        if "cookie" in options:
            command.extend(["--cookie", options["cookie"]])
        
        if "level" in options:
            command.extend(["--level", str(options["level"])])
        
        if "skip" in options:
            command.extend(["--skip", options["skip"]])
        
        if "threads" in options:
            command.extend(["--threads", str(options["threads"])])
        
        if "timeout" in options:
            command.extend(["--timeout", str(options["timeout"])])
        
        # XSStrike hat keine native JSON-Ausgabe, daher leiten wir die Ausgabe in eine Datei um
        command.extend([">", output_file, "2>&1"])
        
        # Ausführen (wir verwenden shell=True, da wir Ausgabeumleitung benötigen)
        try:
            logger.debug(f"Führe Befehl aus: {' '.join(command)}")
            
            # Da wir Ausgabeumleitung verwenden, müssen wir den Befehl als String übergeben
            cmd_str = " ".join(command)
            
            result = subprocess.run(
                cmd_str,
                shell=True,
                timeout=timeout
            )
            
            returncode = result.returncode
            stderr = ""
            
            # Lese die Ausgabe aus der Datei
            stdout = ""
            try:
                with open(output_file, "r") as f:
                    stdout = f.read()
            except Exception as e:
                logger.error(f"Fehler beim Lesen der Ausgabedatei: {e}")
                stderr = str(e)
            
        except subprocess.TimeoutExpired:
            logger.warning(f"Timeout bei der Ausführung von: {' '.join(command)}")
            returncode = -1
            stdout = ""
            stderr = f"Timeout nach {timeout} Sekunden"
            
        except Exception as e:
            logger.error(f"Fehler bei der Ausführung von {' '.join(command)}: {e}")
            returncode = -1
            stdout = ""
            stderr = str(e)
        
        # Ergebnisse verarbeiten
        results = {
            "tool": self._get_tool_name(),
            "target": target,
            "command": " ".join(command),
            "returncode": returncode,
            "vulnerabilities": [],
            "raw_output": stdout,
            "error": stderr if returncode != 0 else ""
        }
        
        # Versuche, die Ergebnisse aus der Ausgabe zu extrahieren
        if returncode == 0 and stdout:
            # XSS-Payloads extrahieren
            payloads = re.findall(r'Payload: (.*?)(?:\n|$)', stdout)
            
            # Reflektierte Parameter extrahieren
            reflected_params = re.findall(r'Reflections found in: (.*?)(?:\n|$)', stdout)
            
            # DOM-XSS-Schwachstellen extrahieren
            dom_xss = re.findall(r'Potentially vulnerable objects found: (.*?)(?:\n|$)', stdout)
            
            # WAF-Erkennung extrahieren
            waf_detected = "WAF detected:" in stdout
            waf_name = ""
            if waf_detected:
                waf_match = re.search(r'WAF detected: (.*?)(?:\n|$)', stdout)
                if waf_match:
                    waf_name = waf_match.group(1)
            
            # Ergebnisse zusammenfassen
            for i, payload in enumerate(payloads):
                vulnerability = {
                    "type": "XSS",
                    "payload": payload,
                    "reflected_params": reflected_params[i] if i < len(reflected_params) else "",
                    "severity": "high"
                }
                results["vulnerabilities"].append(vulnerability)
            
            for dom in dom_xss:
                vulnerability = {
                    "type": "DOM XSS",
                    "payload": "",
                    "vulnerable_object": dom,
                    "severity": "high"
                }
                results["vulnerabilities"].append(vulnerability)
            
            results["waf_detected"] = waf_detected
            results["waf_name"] = waf_name
        
        # Temporäre Datei löschen, falls erstellt
        if temp_output and os.path.exists(temp_output):
            try:
                os.remove(temp_output)
            except Exception as e:
                logger.warning(f"Konnte temporäre Datei nicht löschen: {e}")
        
        return results


class DalfoxIntegration(ToolIntegration):
    """Integration für das Dalfox Tool."""

    def _get_tool_name(self) -> str:
        """
        Gibt den Namen des Tools zurück.
        
        Returns:
            Der Name des Tools.
        """
        return "dalfox"
    
    def _get_installation_command(self) -> List[str]:
        """
        Gibt den Befehl zur Installation des Tools zurück.
        
        Returns:
            Eine Liste mit dem Installationsbefehl und seinen Argumenten.
        """
        return ["go", "install", "github.com/hahwul/dalfox/v2@latest"]
    
    def run(self, target: str, options: Optional[Dict[str, Any]] = None) -> Dict[str, Any]:
        """
        Führt Dalfox mit den angegebenen Optionen aus.
        
        Args:
            target: Die Ziel-URL.
            options: Zusätzliche Optionen für Dalfox.
            
        Returns:
            Ein Dictionary mit den Ergebnissen der Ausführung.
        """
        if not self.executable_path:
            return {"error": f"{self._get_tool_name()} nicht gefunden oder installiert"}
        
        if options is None:
            options = {}
        
        # Standardoptionen
        timeout = options.get("timeout", 120)
        output_file = options.get("output_file", "")
        
        # Kommando zusammenstellen
        command = [
            self.executable_path,
            "url", target,
            "--format", "json"
        ]
        
        # Optionale Parameter
        if "param" in options:
            command.extend(["--param", options["param"]])
        
        if "cookie" in options:
            command.extend(["--cookie", options["cookie"]])
        
        if "headers" in options:
            for header, value in options["headers"].items():
                command.extend(["--header", f"{header}: {value}"])
        
        if "user_agent" in options:
            command.extend(["--user-agent", options["user_agent"]])
        
        if "proxy" in options:
            command.extend(["--proxy", options["proxy"]])
        
        if "delay" in options:
            command.extend(["--delay", str(options["delay"])])
        
        if "timeout" in options:
            command.extend(["--timeout", str(options["timeout"])])
        
        if "concurrency" in options:
            command.extend(["--worker", str(options["concurrency"])])
        
        if "blind" in options and options["blind"]:
            command.extend(["--blind", options["blind"]])
        
        if output_file:
            command.extend(["--output", output_file])
        
        # Ausführen
        returncode, stdout, stderr = self.execute_command(command, timeout=timeout+30)
        
        # Ergebnisse verarbeiten
        results = {
            "tool": self._get_tool_name(),
            "target": target,
            "command": " ".join(command),
            "returncode": returncode,
            "vulnerabilities": [],
            "error": stderr if returncode != 0 else ""
        }
        
        if returncode == 0:
            # Verarbeite die Ausgabe
            try:
                if stdout.strip():
                    data = json.loads(stdout)
                    
                    # Verarbeite die Ergebnisse
                    if "vulnerabilities" in data:
                        for vuln in data["vulnerabilities"]:
                            vulnerability = {
                                "type": vuln.get("type", "XSS"),
                                "payload": vuln.get("payload", ""),
                                "context": vuln.get("context", ""),
                                "confidence": vuln.get("confidence", "medium"),
                                "severity": "high" if vuln.get("confidence", "") == "high" else "medium"
                            }
                            results["vulnerabilities"].append(vulnerability)
                    
                    # Verarbeite die Schwachstellen-Details
                    if "poc" in data:
                        for poc in data["poc"]:
                            vulnerability = {
                                "type": "XSS",
                                "payload": poc.get("payload", ""),
                                "evidence": poc.get("evidence", ""),
                                "severity": "high"
                            }
                            results["vulnerabilities"].append(vulnerability)
                    
                    # Verarbeite die Parameter-Informationen
                    if "parameters" in data:
                        results["parameters"] = data["parameters"]
                    
                    # Verarbeite die WAF-Informationen
                    if "waf" in data:
                        results["waf_detected"] = data["waf"].get("detected", False)
                        results["waf_name"] = data["waf"].get("name", "")
            except json.JSONDecodeError:
                logger.warning("Konnte JSON nicht parsen, versuche alternative Extraktion")
                
                # Fallback für nicht-JSON-Ausgabe
                xss_matches = re.findall(r'\[V\]\s+Reflected XSS:\s+(.*?)(?:\n|$)', stdout)
                for match in xss_matches:
                    vulnerability = {
                        "type": "XSS",
                        "payload": match,
                        "severity": "high"
                    }
                    results["vulnerabilities"].append(vulnerability)
        
        return results


class VulnerabilityScannerFactory:
    """Factory-Klasse für Vulnerability Scanner Integrationen."""
    
    @staticmethod
    def create(scanner_type: str, config: Dict[str, Any]) -> ToolIntegration:
        """
        Erstellt eine Vulnerability Scanner Integration basierend auf dem angegebenen Typ.
        
        Args:
            scanner_type: Der Typ des Scanners ("nuclei", "xsstrike" oder "dalfox").
            config: Die Konfiguration für den Scanner.
            
        Returns:
            Eine Vulnerability Scanner Integration.
            
        Raises:
            ValueError: Wenn der angegebene Typ nicht unterstützt wird.
        """
        if scanner_type.lower() == "nuclei":
            return NucleiIntegration(config)
        elif scanner_type.lower() == "xsstrike":
            return XSStrikeIntegration(config)
        elif scanner_type.lower() == "dalfox":
            return DalfoxIntegration(config)
        else:
            raise ValueError(f"Nicht unterstützter Vulnerability Scanner Typ: {scanner_type}")
